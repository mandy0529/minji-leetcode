​​​​​​​​
## 1. 문제 파악
- 2 pointer로 제시되어있던 문제였지만
- 문제 유형을 딱 보자마자 내가 알고있는 내장함수들을 사용해서 해결하는 방법이 제일 먼저 떠올랐다.
- 대문자를 소문자로 변환하고, 알파벳과 숫자 이외 문자를 제거하고, 앞으로 읽으나, 뒤로 읽으나 같은 내용을 뽑아내라 라고 문제를 이해했다.
  
## 2. 해결 step
- 주어진 s를 소문자로 변환하고, 띄어쓰기를 없애자
```
s = s.toLowerCase()
```
- 정규 표현식을 사용하여 알파벳과 숫자 이외의 모든 문자를 제거하자 ( 정규표현식을 사용해야한다고 바로 떠올랐기때문에 검색해서 이용)
- [^a-z0-9]/g는 알파벳 소문자와 숫자를 제외한 모든 문자를 찾는 패턴이다.
- 이 모든걸 ''로 빈값으로 대체해서 해당 문자들을 전부 제거하겠다.
```
s = s.replace(/[^a-z0-9]/g, '');
```
- 만약 현재 날짜의 가격보다 다음 날짜의 가격이 더 높다면, 이 날에 주식을 사서 다음 날에 판매할 때 이익을 얻을 수 있다.
```
return s === s.split('').reverse().join('');
```

## 4. 내 코드 결과

```
var isPalindrome = function(s) {
    s = s.toLowerCase().trim();
    s = s.replace(/[^a-z0-9]/g, '');
    return s === s.split('').reverse().join('');
};
```

## 5. solution 본 후, 회고
#### 1. solution 해석
- 주어진 s를 소문자로 변환하고,
- 알파벳 소문자와 숫자 이외의 문자를 모두 제거하여 newStr 변수에 할당하였다.
- 이렇게 함으로써 대소문자를 무시하고 알파벳 소문자와 숫자만 남게 된다.
- left와 right라는 변수를 선언하고 초기값을 할당하도록 2 pointer로 접근하였다.
- 이 두 변수는 문자열을 양쪽에서 가운데로 좁혀오면서 비교하는 데 사용된다.
- left는 문자열의 시작을, right는 문자열의 끝이다.
- 반복문을 사용하여 left가 right보다 작을 때까지 비교해 나간다.
- 이렇게 함으로써 문자열을 양쪽에서 가운데로 좁혀오면서 문자를 비교한다.
- 현재 left와 right 위치에서의 문자가 다르다면 회문이 아니므로 false를 반환하고 함수를 종료한다.
- 그렇지 않은 경우에는 left를 증가,
- right를 감소시켜 다음 문자를 비교하한다.
- 반복문을 통과하였고 모든 문자들이 같다면 true를 반환
```
var isPalindrome = function(s) {
    let newStr = s.toLowerCase().replace(/[^0-9a-z]/g, "");
    let left = 0, right = newStr.length-1;
    
    while(left < right){
        if(newStr[left] !== newStr[right]) return false
        left++
        right--
    }
    return true
};
```
- 
#### 2. 회고
- 내가 해결했던것보다 memory적으로 더 좋았다.
- 2pointer태그가 달려있던 문제니까 앞으로는 먼저 생각나는 나만의 해결방법이여도, 태그에 맞게 구상하고, 코드적으로 실행해보는게 좋을 것 같다는 생각을 했다.
- 앞뒤가 같으므로, 반복문을 첫포인트부터 끝포인트까지 돌리는데
- 그것이 같으면 true 같지않으면 false를 해나가며 left는 커지고, right은 작아지는 형태로 반복문을 구상하면 된다.
- 앞으로 2 pointer를 어떻게 접근해 나가면 좋을지 조금 습관이 된 것 같아 좋다.


