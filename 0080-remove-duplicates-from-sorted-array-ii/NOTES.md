​​​
## 1. 문제 파악
- 1,2,3번과 마찬가지로 in-place algorithm을 사용하여 해결 하자라고 생각
- 숫자들의 순서는 상관없이 어차피 중복되지않은 숫자에다가 중복되는 숫자가 있다면 최대 2개씩 플러스 한 k값만 리턴 해주자라고 생각

## 2. 해결 step
- 중복되지 않은 숫자들을 배열의 앞부분부터 채우기 위한 인덱스 포인터 설정
```
let k = 0;
```
- nums 배열 for 문으로 돌리면서
```
for(let num of nums) {}

```
- 중복을 최대 두 번까지만 허용하면서 중복되지 않은 숫자들을 찾기 위한 조건을 만들어야하는데
- 첫번째 if조건은 k가 2보다 작을 때, 이 경우는 처음 두 숫자까지는 중복이 허용되므로 해당 숫자를 그대로 삽입
- 두번째 if조건은 현재 숫자 num이 이전에 중복으로 삽입한 숫자와 다를 때, 이 경우에만 현재 숫자 num을 삽입
```
if(k < 2 || num !== nums[k - 2]) {}
```
- 위의 조건을 만족하는 경우, 
- 현재 숫자 num을 nums 배열의 인덱스 k에 넣는다.
- 그리고 k는 1씩 증가
- 이렇게 함으로써 중복이 최대 두 번까지 허용되면서 중복되지 않은 숫자들이 배열이 채워짐.
```
nums[k]=num;
k++; 
```
- for문 반복문 나와서 nums의 중복된아이가 최대 2번 허용한 숫자까지 유용하므로 k를 리턴해줘야한다.
```
 return k
``````

## 3. 요약
- nums가 가질 수 있는 해당 인덱스 k를 리턴하는거의 핵심
- 중복되지 않은 수는 넣고, 중복되는 수는 최대 2번만 허용하도록 조건문 구성하기

```
var removeDuplicates = function(nums) {
    let k = 0;
    for(let num of nums) {
        if(k < 2 || num !== nums[k - 2]) {
            nums[k]=num;
            k++;
        }
    }
    return k
};
```

## 4. solution 본 후, 회고
#### 1. 해결방법
- 처음 특수 케이스를 지정해줬다. nums.length의 길이가 2와 같거나 2보다 작을때 nums.length를 그대로 반환 => 중복된수 2개든 중복되지 않은수 + 다른 숫자든 2개는 무조건 가지고 가기 때문에 그대로 length 반환
- 그리고 첫번째 포인터를 인덱스 2부터 잡아도되니 k를 2로 지정
- for문 nums.length까지 돌리고 두번째 포인터 i를 2로 지정
- 최대 중복 2개이거나 다음 숫자랑 중복되지 않을 때 복사한다음 k증가
- k 리턴
#### 2. 회고
- 솔루션에서는 일단 nums의 2글자는 허용되니까 특수케이스로 if문으로 끌고나간다음, for문으로 나머지 최대 2개중복 허용, 1개 중복되든 안되든 허용 코드로 구성했다.
- 나의 해결 방법은 나는 for문에서 nums를 반복문 돌려준 다음, 첫번째 포인터 k값을 0으로 잡아준 후, 2번째자리까지 허용, 최대 중복2까지 허용 조건문을 같이 써줬다.
- 내 코드가 더 짧지만, 솔루션 코드가 더 직관적이였던 것 같다.
```
var removeDuplicates = function(nums) {
    if(nums.length <= 2) {
        return nums.length;
    }
    let k = 2;
    for(let i = 2; i < nums.length; i++){
        if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]){
            nums[k] = nums[i];
            k++;
        }
    }
    return k;      
};
