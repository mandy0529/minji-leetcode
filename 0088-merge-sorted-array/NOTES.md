## 문제 직면
- 문제부터 이해하는데 시간이 꽤나 걸렸다.
- 처음 테스트 코드에 0이 들어 있었기에 0을 빼야한다는생각에 filter를 사용하며 새로운 배열을 만들게되며 새로운 배열을 계속 반환했다.
- 그 결과, 헤메며, 원하는 값을 계속 얻지 못했다.
- 문제를 천천히 읽어보고, 이해해보니, *함수는 정렬된 결과 배열을 반환해서는 안 되며, 대신 결과는 nums1 배열 안에 저장되어야 한다는 핵심* 을 발견 했다.

## 해결 step
- nums1을 바꾸는게 이 문제를 푸는 핵심이라고 생각했고, m+n이 nums배열의 length가 된다.
- 그래서 도전해본 방법은 nums1 배열에다가 m만큼 원소는 그대로 가져가고, n만큼 num1 배열에 nums2 원소 전부를 집어넣자
- 그 다음에 sort해서 오름차순 정렬 해주고,
- nums1이 가져야하는 length만큼 slice 해주자

```
var merge = function(nums1, m, nums2, n) {
    // nums1 배열에 nums2 배열의 원소를 병합
    // splice() 메서드를 사용하여 m 위치부터 n 개의 원소를 nums2 배열의 원소로 대체
    // 여기서 ...nums2는 nums2 배열의 원소들을 전개하여 개별 원소로 확장하는 역할 
    // 따라서 nums1 배열의 m 위치부터 n 개의 원소가 nums2 배열의 원소로 대체
    nums1.splice(m, n, ...nums2);

    // nums1 배열을 오름차순으로 정렬, m length만큼 끊기
    nums1.sort((a, b) => a - b).slice(0, m);
};
```
